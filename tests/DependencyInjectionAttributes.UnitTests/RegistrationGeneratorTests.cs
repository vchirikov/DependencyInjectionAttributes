using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;

namespace DependencyInjectionAttributes.UnitTests;

public class GeneratorTests
{
  [Fact]
  public void Should_Generate_For_ServiceAttribute()
  {
    const string input = """
                         using Microsoft.Extensions.DependencyInjection;

                         interface IBar {}

                         [Service(ServiceLifetime.Scoped)]
                         public class Bar: IBar {};
                         """;

    var generated = GenerateSourceText(input, new() {
      { "DesignBuild", "false" },
      { "AddServicesExtension", "true" },
    }, out _, out _);

    string? actual = generated.FirstOrDefault(x => x.Contains("AddScopedServices", StringComparison.Ordinal));

    string expected = """
                      // <auto-generated />
                      using Microsoft.Extensions.DependencyInjection.Extensions;
                      using System;

                      namespace Microsoft.Extensions.DependencyInjection
                      {
                          static partial class AddServicesFromSourceGenerator
                          {
                              static partial void AddScopedServices(IServiceCollection services)
                              {
                                  services.TryAddScoped(s => new global::Bar());
                                  services.AddTransient<Func<global::Bar>>(s => s.GetRequiredService<global::Bar>);
                                  services.AddTransient(s => new Lazy<global::Bar>(s.GetRequiredService<global::Bar>));
                                  services.AddScoped<global::IBar>(s => s.GetRequiredService<global::Bar>());
                                  services.AddTransient<Func<global::IBar>>(s => s.GetRequiredService<global::IBar>);
                                  services.AddTransient(s => new Lazy<global::IBar>(s.GetRequiredService<global::IBar>));
                              }
                          }
                      }

                      """.Replace("\r\n", "\n", StringComparison.Ordinal);
    Assert.Equal(expected, actual);
  }

  [Fact]
  public void Should_Not_Generate_Without_AddServicesExtension()
  {
    const string input = """
                         using Microsoft.Extensions.DependencyInjection;

                         interface IBar {}

                         [Service(ServiceLifetime.Scoped)]
                         public class Bar: IBar {};
                         """;

    var generated = GenerateSourceText(input, new() {
      { "DesignBuild", "false" },
      { "AddServicesExtension", "false" },
    }, out _, out _);

    Assert.Empty(generated);
  }

  public static string[] GenerateSourceText(string input,
    Dictionary<string, string> buildProperties,
    out Compilation outputCompilation,
    out ImmutableArray<Diagnostic> diagnostics
  )
  {
    RegistrationGenerator generator = new();
    var options = A.Fake<AnalyzerConfigOptions>();
    string? outString;
    foreach (var (buildProperty, val) in buildProperties) {
      A.CallTo(() => options.TryGetValue($"build_property.{buildProperty}", out outString))
        .Returns(true)
        .AssignsOutAndRefParameters(val);
    }

    var optionsProvider = A.Fake<AnalyzerConfigOptionsProvider>();
    A.CallTo(() => optionsProvider.GlobalOptions).Returns(options);
    A.CallTo(() => optionsProvider.GetOptions(A<AdditionalText>._)).Returns(options);
    A.CallTo(() => optionsProvider.GetOptions(A<SyntaxTree>._)).Returns(options);

    GeneratorDriver driver =
      CSharpGeneratorDriver.Create([generator.AsSourceGenerator()], optionsProvider: optionsProvider);
    driver = driver.RunGeneratorsAndUpdateCompilation(CreateCompilation(input), out outputCompilation, out diagnostics);

    GeneratorDriverRunResult runResult = driver.GetRunResult();
    GeneratorRunResult generatorResult = runResult.Results[0];
    return [
      ..generatorResult.GeneratedSources.Select(result => result.SourceText.ToString()),
    ];

    static Compilation CreateCompilation(
      string source,
      MetadataReference[]? additionalReferences = null,
      CSharpParseOptions? parseOptions = null,
      CSharpCompilationOptions? compilationOptions = null
    )
    {
      const string serviceAttrFileContent =
        """
        // <auto-generated />
        #nullable enable

        using System;

        namespace Microsoft.Extensions.DependencyInjection
        {
          /// <summary>
          /// Configures the registration of a service in an <see cref="IServiceCollection"/> via `AddServices` extension
          /// </summary>
          [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
          partial class ServiceAttribute : Attribute
          {
            /// <summary>
            /// Annotates the service with the lifetime
            /// </summary>
            public ServiceAttribute(ServiceLifetime lifetime) { }

            /// <summary>
            /// Annotates the keyed service with the key and lifetime
            /// </summary>
            public ServiceAttribute(object key, ServiceLifetime lifetime) { }
          }
        }
        """;

      DirectoryInfo coreDir = Directory.GetParent(typeof(Enumerable).Assembly.Location) ??
                              throw new Exception("Can't find parent directory of dotnet sdk");

      List<MetadataReference> references = [
        MetadataReference.CreateFromFile(Path.Combine(coreDir.FullName, "mscorlib.dll")),
        MetadataReference.CreateFromFile(Path.Combine(coreDir.FullName, "System.Runtime.dll")),
        MetadataReference.CreateFromFile(Path.Combine(coreDir.FullName, "System.Collections.dll")),
        MetadataReference.CreateFromFile(Path.Combine(coreDir.FullName, "System.Data.Common.dll")),


        MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
        // System.Collections.Concurrent
        MetadataReference.CreateFromFile(typeof(ConcurrentDictionary<,>).Assembly.Location),
        // System.Linq
        MetadataReference.CreateFromFile(typeof(System.Linq.Enumerable).Assembly.Location),
        // System.Linq.Expressions
        MetadataReference.CreateFromFile(typeof(System.Linq.Expressions.DynamicExpression).Assembly.Location),
        // System.Memory
        MetadataReference.CreateFromFile(typeof(System.Buffers.MemoryPool<>).Assembly.Location),
        // System.ComponentModel.dll
        MetadataReference.CreateFromFile(typeof(IServiceProvider).Assembly.Location),
        // Microsoft.Extensions.DependencyInjection.Abstractions.dll
        MetadataReference.CreateFromFile(typeof(Microsoft.Extensions.DependencyInjection.ServiceLifetime).Assembly
          .Location),
        MetadataReference.CreateFromFile(typeof(System.IO.FileSystemInfo).Assembly.Location),
        MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
        MetadataReference.CreateFromFile(typeof(MarshalByValueComponent).Assembly.Location),
        MetadataReference.CreateFromFile(typeof(Binder).Assembly.Location),
        MetadataReference.CreateFromFile(typeof(ObservableCollection<string>).Assembly.Location),
      ];

      if (additionalReferences != null) {
        references.AddRange(additionalReferences);
      }

      return CSharpCompilation.Create(
        assemblyName: Guid.NewGuid().ToString("N") + ".dll",
        options: compilationOptions ?? new(OutputKind.DynamicallyLinkedLibrary),
        references: references.Distinct().ToArray(),
        syntaxTrees: [
          CSharpSyntaxTree.ParseText(source, parseOptions),
          CSharpSyntaxTree.ParseText(serviceAttrFileContent, parseOptions),
        ]
      );
    }
  }
}
